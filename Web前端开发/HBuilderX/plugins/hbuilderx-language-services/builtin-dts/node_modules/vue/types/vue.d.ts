import {
  Component,
  AsyncComponent,
  ComponentOptions,
  FunctionalComponentOptions,
  WatchOptionsWithHandler,
  WatchHandler,
  DirectiveOptions,
  DirectiveFunction,
  RecordPropsDefinition,
  ThisTypedComponentOptionsWithArrayProps,
  ThisTypedComponentOptionsWithRecordProps,
  WatchOptions,
} from "./options";
import { VNode, VNodeData, VNodeChildren, NormalizedScopedSlot } from "./vnode";
import { PluginFunction, PluginObject } from "./plugin";

export interface VueEventString extends String {}
export interface VueDataString extends String {}

export interface CreateElement {
  (tag?: string | Component<any, any, any, any> | AsyncComponent<any, any, any, any> | (() => Component), children?: VNodeChildren): VNode;
  (tag?: string | Component<any, any, any, any> | AsyncComponent<any, any, any, any> | (() => Component), data?: VNodeData, children?: VNodeChildren): VNode;
}

export interface Vue {
  /**
   * vue.2.Vue.el
   */
  readonly $el: Element;
  /**
   * vue.2.Vue.options
   */  
  readonly $options: ComponentOptions<Vue>;
  /**
   * vue.2.Vue.parent
   */
  readonly $parent: Vue;
  /**
   * vue.2.Vue.root
   */
  readonly $root: Vue;
  /**
   * vue.2.Vue.children
   */
  readonly $children: Vue[];
  /**
   * vue.2.Vue.refs
   */
  readonly $refs: { [key: string]: Vue | Element | (Vue | Element)[] | undefined };
  /**
   * vue.2.Vue.slots
   */
  readonly $slots: { [key: string]: VNode[] | undefined };
  /**
   * vue.2.Vue.scopedSlots
   */
  readonly $scopedSlots: { [key: string]: NormalizedScopedSlot | undefined };
  /**
   * vue.2.Vue.isServer
   */  
  readonly $isServer: boolean;
  /**
   * vue.2.Vue.data
   */
  readonly $data: Record<string, any>;
  /**
   * vue.2.Vue.props
   */
  readonly $props: Record<string, any>;
  readonly $ssrContext: any;
  readonly $vnode: VNode;
  /**
   * vue.2.Vue.attrs
   */
  readonly $attrs: Record<string, string>;
  /**
   * vue.2.Vue.listeners
   */
  readonly $listeners: Record<string, Function | Function[]>;

  /**
   * vue.2.Vue.mount
   */
  $mount(elementOrSelector?: Element | string, hydrating?: boolean): this;
  /**
   * vue.2.Vue.forceUpdate
   */
  $forceUpdate(): void;
  /**
   * vue.2.Vue.destroy
   */
  $destroy(): void;
  /**
   * vue.2.Vue.set
   */
  $set: typeof Vue.set;
  /**
   * vue.2.Vue.delete
   */  
  $delete: typeof Vue.delete;
  /**
   * vue.2.Vue.watch
   */
  $watch(
    expOrFn: string | VueDataString,
    callback: (this: this, n: any, o: any) => void,
    options?: WatchOptions
  ): (() => void);
  /**
   * vue.2.Vue.watch
   */
  $watch<T>(
    expOrFn: (this: this) => T,
    callback: (this: this, n: T, o: T) => void,
    options?: WatchOptions
  ): (() => void);
  /**
   * vue.2.Vue.on
   */
  $on(event: string | string[], callback: Function): this;
  /**
   * vue.2.Vue.once
   */
  $once(event: string | string[], callback: Function): this;
  /**
   * vue.2.Vue.off
   */
  $off(event?: string | string[], callback?: Function): this;
  /**
   * vue.2.Vue.emit
   */
  $emit(event: string | VueEventString, ...args: any[]): this;
  /**
   * vue.2.Vue.nextTick
   */
  $nextTick(callback: (this: this) => void): void;
  /**
   * vue.2.Vue.nextTick
   */
  $nextTick(): Promise<void>;
  $createElement: CreateElement;
}

export type CombinedVueInstance<Instance extends Vue, Data, Methods, Computed, Props> =  Data & Methods & Computed & Props & Instance;
export type ExtendedVue<Instance extends Vue, Data, Methods, Computed, Props> = VueConstructor<CombinedVueInstance<Instance, Data, Methods, Computed, Props> & Vue>;

export interface VueConfiguration {
  /**
   * vue.2.VueConfiguration.slient
   */
  silent: boolean;
  /**
   * vue.2.VueConfiguration.optionMergeStrategies
   */
  optionMergeStrategies: any;
  /**
   * vue.2.VueConfiguration.devtools
   */
  devtools: boolean;
  /**
   * vue.2.VueConfiguration.productionTip
   */
  productionTip: boolean;
  /**
   * vue.2.VueConfiguration.performance
   */
  performance: boolean;
  /**
   * vue.2.VueConfiguration.errorHandler
   */
  errorHandler(err: Error, vm: Vue, info: string): void;
  /**
   * vue.2.VueConfiguration.warnHandler
   */
  warnHandler(msg: string, vm: Vue, trace: string): void;
  /**
   * vue.2.VueConfiguration.ignoredElements
   */
  ignoredElements: (string | RegExp)[];
  /**
   * vue.2.VueConfiguration.keyCodes
   */
  keyCodes: { [key: string]: number | number[] };
  async: boolean;
}

export interface VueConstructor<V extends Vue = Vue> {
  new <Data = object, Methods = object, Computed = object, PropNames extends string = never>(options?: ThisTypedComponentOptionsWithArrayProps<V, Data, Methods, Computed, PropNames>): CombinedVueInstance<V, Data, Methods, Computed, Record<PropNames, any>>;
  // ideally, the return type should just contain Props, not Record<keyof Props, any>. But TS requires to have Base constructors with the same return type.
  new <Data = object, Methods = object, Computed = object, Props = object>(options?: ThisTypedComponentOptionsWithRecordProps<V, Data, Methods, Computed, Props>): CombinedVueInstance<V, Data, Methods, Computed, Record<keyof Props, any>>;
  new (options?: ComponentOptions<V>): CombinedVueInstance<V, object, object, object, Record<keyof object, any>>;

  /**
   * vue.2.VueConstructor.extend
   */
  extend<Data, Methods, Computed, PropNames extends string = never>(options?: ThisTypedComponentOptionsWithArrayProps<V, Data, Methods, Computed, PropNames>): ExtendedVue<V, Data, Methods, Computed, Record<PropNames, any>>;
  /**
   * vue.2.VueConstructor.extend
   */
  extend<Data, Methods, Computed, Props>(options?: ThisTypedComponentOptionsWithRecordProps<V, Data, Methods, Computed, Props>): ExtendedVue<V, Data, Methods, Computed, Props>;
  /**
   * vue.2.VueConstructor.extend
   */  
  extend<PropNames extends string = never>(definition: FunctionalComponentOptions<Record<PropNames, any>, PropNames[]>): ExtendedVue<V, {}, {}, {}, Record<PropNames, any>>;
  /**
   * vue.2.VueConstructor.extend
   */  
  extend<Props>(definition: FunctionalComponentOptions<Props, RecordPropsDefinition<Props>>): ExtendedVue<V, {}, {}, {}, Props>;
  /**
   * vue.2.VueConstructor.extend
   */  
  extend(options?: ComponentOptions<V>): ExtendedVue<V, {}, {}, {}, {}>;

  /**
   * vue.2.VueConstructor.nextTick
   */
  nextTick<T>(callback: (this: T) => void, context?: T): void;
  /**
   * vue.2.VueConstructor.nextTick
   */
  nextTick(): Promise<void>
  /**
   * vue.2.VueConstructor.set
   */
  set<T>(object: object, key: string | number, value: T): T;
  /**
   * vue.2.VueConstructor.set
   */
  set<T>(array: T[], key: number, value: T): T;
  /**
   * vue.2.VueConstructor.delete
   */
  delete(object: object, key: string | number): void;
  /**
   * vue.2.VueConstructor.delete
   */
  delete<T>(array: T[], key: number): void;

  /**
   * vue.2.VueConstructor.directive
   */
  directive(
    id: string,
    definition?: DirectiveOptions | DirectiveFunction
  ): DirectiveOptions;
  /**
   * vue.2.VueConstructor.filter
   */
  filter(id: string, definition?: Function): Function;

  /**
   * vue.2.VueConstructor.component
   */
  component(id: string): VueConstructor;
  /**
   * vue.2.VueConstructor.component
   */
  component<VC extends VueConstructor>(id: string, constructor: VC): VC;
  /**
   * vue.2.VueConstructor.component
   */
  component<Data, Methods, Computed, Props>(id: string, definition: AsyncComponent<Data, Methods, Computed, Props>): ExtendedVue<V, Data, Methods, Computed, Props>;
  /**
   * vue.2.VueConstructor.component
   */
  component<Data, Methods, Computed, PropNames extends string = never>(id: string, definition?: ThisTypedComponentOptionsWithArrayProps<V, Data, Methods, Computed, PropNames>): ExtendedVue<V, Data, Methods, Computed, Record<PropNames, any>>;
  /**
   * vue.2.VueConstructor.component
   */
  component<Data, Methods, Computed, Props>(id: string, definition?: ThisTypedComponentOptionsWithRecordProps<V, Data, Methods, Computed, Props>): ExtendedVue<V, Data, Methods, Computed, Props>;
  /**
   * vue.2.VueConstructor.component
   */
  component<PropNames extends string>(id: string, definition: FunctionalComponentOptions<Record<PropNames, any>, PropNames[]>): ExtendedVue<V, {}, {}, {}, Record<PropNames, any>>;
  /**
   * vue.2.VueConstructor.component
   */
  component<Props>(id: string, definition: FunctionalComponentOptions<Props, RecordPropsDefinition<Props>>): ExtendedVue<V, {}, {}, {}, Props>;
  /**
   * vue.2.VueConstructor.component
   */
  component(id: string, definition?: ComponentOptions<V>): ExtendedVue<V, {}, {}, {}, {}>;

  /**
   * vue.2.VueConstructor.use
   */
  use<T>(plugin: PluginObject<T> | PluginFunction<T>, options?: T): VueConstructor<V>;
  /**
   * vue.2.VueConstructor.use
   */  
  use(plugin: PluginObject<any> | PluginFunction<any>, ...options: any[]): VueConstructor<V>;
  /**
   * vue.2.VueConstructor.mixin
   */
  mixin(mixin: VueConstructor | ComponentOptions<Vue>): VueConstructor<V>;
  /**
   * vue.2.VueConstructor.compile
   */
  compile(template: string): {
    render(createElement: typeof Vue.prototype.$createElement): VNode;
    staticRenderFns: (() => VNode)[];
  };

  observable<T>(obj: T): T;

  util: {
    warn(msg: string, vm?: InstanceType<VueConstructor>): void;
  };

  /**
   * vue.2.VueConstructor.config
   */
  config: VueConfiguration;
  /**
   * vue.2.VueConstructor.version
   */
  version: string;
}

export const Vue: VueConstructor;
